#!/bin/bash
# =============================================================================
# Flutter Grist API - Backup Restore Script
# =============================================================================
# This script restores application data from a backup archive
#
# Usage:
#   ./restore.sh <backup_file.tar.gz>
#   ./restore.sh --list     # List available backups
#   ./restore.sh --latest   # Restore latest backup
#
# Generated by Ansible - DO NOT EDIT MANUALLY
# =============================================================================

set -euo pipefail

# Configuration
BACKUP_BASE_DIR="{{ backup_base_dir }}"
TEMP_RESTORE_DIR="/tmp/restore_$$"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

# List available backups
list_backups() {
    log "=========================================="
    log "Available Backups"
    log "=========================================="

    for TYPE in daily weekly monthly; do
        echo ""
        echo "${TYPE^} backups:"
        find "${BACKUP_BASE_DIR}/${TYPE}" -name "*.tar.gz" -type f -printf '%T@ %p\n' 2>/dev/null | \
            sort -rn | \
            while read -r TIMESTAMP FILE; do
                SIZE=$(du -h "$FILE" | cut -f1)
                DATE=$(date -d "@${TIMESTAMP}" "+%Y-%m-%d %H:%M:%S")
                BASENAME=$(basename "$FILE")
                echo "  $DATE - $BASENAME ($SIZE)"
            done || echo "  No backups found"
    done

    echo ""
    log "=========================================="
}

# Find latest backup
find_latest_backup() {
    find "${BACKUP_BASE_DIR}" -name "*.tar.gz" -type f -printf '%T@ %p\n' | \
        sort -rn | \
        head -1 | \
        cut -d' ' -f2-
}

# Verify backup before restore
verify_backup() {
    local backup_file="$1"

    log "Verifying backup before restore..."

    # Check if file exists
    if [ ! -f "$backup_file" ]; then
        error "Backup file not found: $backup_file"
        return 1
    fi

    # Verify checksum if available
    if [ -f "${backup_file}.sha256" ]; then
        cd "$(dirname "$backup_file")"
        if sha256sum -c "$(basename "${backup_file}.sha256")" --quiet; then
            success "Checksum verification passed"
        else
            error "Checksum verification failed!"
            return 1
        fi
    else
        warning "No checksum file found - skipping verification"
    fi

    # Test archive integrity
    if tar -tzf "$backup_file" > /dev/null 2>&1; then
        success "Archive integrity verified"
    else
        error "Archive is corrupted!"
        return 1
    fi

    return 0
}

# Restore backup
restore_backup() {
    local backup_file="$1"

    log "=========================================="
    log "Starting restore from: $(basename "$backup_file")"
    log "=========================================="

    # Verify backup
    if ! verify_backup "$backup_file"; then
        error "Backup verification failed - aborting restore"
        exit 1
    fi

    # Confirm restore
    warning "This will replace existing data!"
    read -p "Are you sure you want to continue? (yes/no): " CONFIRM
    if [ "$CONFIRM" != "yes" ]; then
        log "Restore cancelled"
        exit 0
    fi

    # Create temporary restore directory
    mkdir -p "$TEMP_RESTORE_DIR"

    # Extract backup
    log "Extracting backup..."
    tar -xzf "$backup_file" -C "$TEMP_RESTORE_DIR"

    # Find extracted directory
    EXTRACTED_DIR=$(find "$TEMP_RESTORE_DIR" -maxdepth 1 -type d -name "flutter_grist_backup_*" | head -1)

    if [ -z "$EXTRACTED_DIR" ]; then
        error "Could not find extracted backup directory"
        cleanup_temp
        exit 1
    fi

    # Display backup metadata
    if [ -f "$EXTRACTED_DIR/backup_metadata.txt" ]; then
        log ""
        log "Backup metadata:"
        cat "$EXTRACTED_DIR/backup_metadata.txt" | sed 's/^/  /'
        log ""
    fi

    # Stop services before restore
    log "Stopping services..."
    systemctl stop nginx || true
    docker stop grist || true

    # Restore Grist data
    if [ -d "$EXTRACTED_DIR/grist_data" ]; then
        log "Restoring Grist data..."
        GRIST_DATA_DIR="{{ grist_data_dir | default('/opt/grist/data') }}"
        mkdir -p "$GRIST_DATA_DIR"
        rsync -a --delete "$EXTRACTED_DIR/grist_data/" "$GRIST_DATA_DIR/"
        success "Grist data restored"
    fi

    # Restore application configuration
    if [ -d "$EXTRACTED_DIR/app_config" ]; then
        log "Restoring application configuration..."
        APP_CONFIG_DIR="{{ app_config_dir | default('/opt/flutter_grist_app/config') }}"
        mkdir -p "$APP_CONFIG_DIR"
        rsync -a "$EXTRACTED_DIR/app_config/" "$APP_CONFIG_DIR/"
        success "Application config restored"
    fi

    # Restore Nginx configuration
    if [ -d "$EXTRACTED_DIR/nginx_config" ]; then
        log "Restoring Nginx configuration..."
        rsync -a "$EXTRACTED_DIR/nginx_config/" "/etc/nginx/"
        nginx -t && success "Nginx config restored" || warning "Nginx config validation failed"
    fi

    # Restore SSL certificates
    if [ -d "$EXTRACTED_DIR/ssl_certs" ]; then
        log "Restoring SSL certificates..."
        rsync -a "$EXTRACTED_DIR/ssl_certs/" "/etc/letsencrypt/"
        success "SSL certificates restored"
    fi

    # Restart services
    log "Restarting services..."
    docker start grist || true
    sleep 5
    systemctl start nginx || true

    # Cleanup
    cleanup_temp

    success "=========================================="
    success "Restore completed successfully!"
    success "=========================================="
    log "Please verify that all services are running correctly:"
    log "  - Check Grist: docker ps | grep grist"
    log "  - Check Nginx: systemctl status nginx"
    log "  - Check application: curl http://localhost/health"
}

# Cleanup temporary files
cleanup_temp() {
    if [ -d "$TEMP_RESTORE_DIR" ]; then
        rm -rf "$TEMP_RESTORE_DIR"
    fi
}

# Trap cleanup on exit
trap cleanup_temp EXIT

# =============================================================================
# Main
# =============================================================================

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    error "This script must be run as root"
    exit 1
fi

case "${1:-}" in
    --list)
        list_backups
        ;;
    --latest)
        LATEST=$(find_latest_backup)
        if [ -z "$LATEST" ]; then
            error "No backups found"
            exit 1
        fi
        log "Latest backup: $(basename "$LATEST")"
        restore_backup "$LATEST"
        ;;
    *.tar.gz)
        restore_backup "$1"
        ;;
    *)
        echo "Usage: $0 <backup_file.tar.gz>"
        echo "       $0 --list"
        echo "       $0 --latest"
        exit 1
        ;;
esac

exit 0
