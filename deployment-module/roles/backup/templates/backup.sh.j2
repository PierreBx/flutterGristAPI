#!/bin/bash
# =============================================================================
# Flutter Grist API - Automated Backup Script
# =============================================================================
# This script backs up critical application data including:
# - Grist database data
# - Application configuration
# - Nginx configuration
# - SSL certificates (if present)
#
# Usage:
#   ./backup.sh [daily|weekly|monthly|cleanup]
#
# Generated by Ansible - DO NOT EDIT MANUALLY
# =============================================================================

set -euo pipefail

# Source configuration
CONFIG_FILE="/etc/backup.conf"
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Configuration (defaults, can be overridden by backup.conf)
BACKUP_BASE_DIR="${BACKUP_BASE_DIR:-{{ backup_base_dir }}}"
BACKUP_TYPE="${1:-daily}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_NAME="flutter_grist_backup_${BACKUP_TYPE}_${TIMESTAMP}"
TEMP_DIR="${BACKUP_BASE_DIR}/temp/${BACKUP_NAME}"

# Backup sources
GRIST_DATA_DIR="{{ grist_data_dir | default('/opt/grist/data') }}"
APP_CONFIG_DIR="{{ app_config_dir | default('/opt/flutter_grist_app/config') }}"
NGINX_CONFIG_DIR="/etc/nginx"
SSL_CERT_DIR="/etc/letsencrypt"

# Retention periods (in days)
RETENTION_DAILY="{{ backup_retention_daily }}"
RETENTION_WEEKLY="{{ backup_retention_weekly }}"
RETENTION_MONTHLY="{{ backup_retention_monthly }}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# =============================================================================
# Functions
# =============================================================================

log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

# Check if directory exists and is not empty
check_dir() {
    local dir="$1"
    if [ ! -d "$dir" ]; then
        warning "Directory does not exist: $dir"
        return 1
    fi
    if [ -z "$(ls -A "$dir" 2>/dev/null)" ]; then
        warning "Directory is empty: $dir"
        return 1
    fi
    return 0
}

# Create backup archive
create_backup() {
    log "=========================================="
    log "Starting ${BACKUP_TYPE} backup"
    log "=========================================="

    # Create temporary directory
    mkdir -p "$TEMP_DIR"

    # Backup Grist data
    if check_dir "$GRIST_DATA_DIR"; then
        log "Backing up Grist data..."
        mkdir -p "$TEMP_DIR/grist_data"
        rsync -a --quiet "$GRIST_DATA_DIR/" "$TEMP_DIR/grist_data/"
        success "Grist data backed up"
    fi

    # Backup application configuration
    if check_dir "$APP_CONFIG_DIR"; then
        log "Backing up application configuration..."
        mkdir -p "$TEMP_DIR/app_config"
        rsync -a --quiet "$APP_CONFIG_DIR/" "$TEMP_DIR/app_config/"
        success "Application config backed up"
    fi

    # Backup Nginx configuration
    if check_dir "$NGINX_CONFIG_DIR"; then
        log "Backing up Nginx configuration..."
        mkdir -p "$TEMP_DIR/nginx_config"
        rsync -a --quiet "$NGINX_CONFIG_DIR/" "$TEMP_DIR/nginx_config/"
        success "Nginx config backed up"
    fi

    # Backup SSL certificates (if present)
    if check_dir "$SSL_CERT_DIR"; then
        log "Backing up SSL certificates..."
        mkdir -p "$TEMP_DIR/ssl_certs"
        rsync -a --quiet "$SSL_CERT_DIR/" "$TEMP_DIR/ssl_certs/"
        success "SSL certificates backed up"
    fi

    # Create metadata file
    cat > "$TEMP_DIR/backup_metadata.txt" <<EOF
Backup Type: ${BACKUP_TYPE}
Backup Date: $(date)
Hostname: $(hostname)
OS: $(uname -s) $(uname -r)
Backup Script Version: 1.0
EOF

    # Create compressed archive
    log "Creating compressed archive..."
    BACKUP_DEST="${BACKUP_BASE_DIR}/${BACKUP_TYPE}/${BACKUP_NAME}.tar.gz"

    # Use pigz (parallel gzip) if available, otherwise use gzip
    if command -v pigz &> /dev/null; then
        tar -C "${BACKUP_BASE_DIR}/temp" -cf - "${BACKUP_NAME}" | pigz > "$BACKUP_DEST"
    else
        tar -czf "$BACKUP_DEST" -C "${BACKUP_BASE_DIR}/temp" "${BACKUP_NAME}"
    fi

    # Calculate checksum
    log "Calculating checksum..."
    cd "${BACKUP_BASE_DIR}/${BACKUP_TYPE}"
    sha256sum "${BACKUP_NAME}.tar.gz" > "${BACKUP_NAME}.tar.gz.sha256"

    # Cleanup temporary directory
    rm -rf "$TEMP_DIR"

    # Get backup size
    BACKUP_SIZE=$(du -h "$BACKUP_DEST" | cut -f1)

    success "Backup completed: ${BACKUP_DEST}"
    log "Backup size: ${BACKUP_SIZE}"
    log "Checksum: ${BACKUP_DEST}.sha256"
    log "=========================================="

    # Verify backup
    verify_backup "$BACKUP_DEST"
}

# Verify backup integrity
verify_backup() {
    local backup_file="$1"

    log "Verifying backup integrity..."

    # Check if file exists
    if [ ! -f "$backup_file" ]; then
        error "Backup file not found: $backup_file"
        return 1
    fi

    # Verify checksum
    if [ -f "${backup_file}.sha256" ]; then
        cd "$(dirname "$backup_file")"
        if sha256sum -c "$(basename "${backup_file}.sha256")" --quiet; then
            success "Backup verification passed"
        else
            error "Backup verification failed - checksum mismatch!"
            return 1
        fi
    else
        warning "Checksum file not found - skipping verification"
    fi

    # Test archive integrity
    if tar -tzf "$backup_file" > /dev/null 2>&1; then
        success "Archive integrity verified"
    else
        error "Archive is corrupted!"
        return 1
    fi

    return 0
}

# Cleanup old backups
cleanup_old_backups() {
    log "=========================================="
    log "Cleaning up old backups"
    log "=========================================="

    # Cleanup daily backups older than retention period
    log "Cleaning daily backups older than ${RETENTION_DAILY} days..."
    find "${BACKUP_BASE_DIR}/daily" -name "*.tar.gz" -type f -mtime +${RETENTION_DAILY} -delete
    find "${BACKUP_BASE_DIR}/daily" -name "*.sha256" -type f -mtime +${RETENTION_DAILY} -delete

    # Cleanup weekly backups older than retention period (in days)
    log "Cleaning weekly backups older than ${RETENTION_WEEKLY} days..."
    find "${BACKUP_BASE_DIR}/weekly" -name "*.tar.gz" -type f -mtime +${RETENTION_WEEKLY} -delete
    find "${BACKUP_BASE_DIR}/weekly" -name "*.sha256" -type f -mtime +${RETENTION_WEEKLY} -delete

    # Cleanup monthly backups older than retention period (in days)
    log "Cleaning monthly backups older than ${RETENTION_MONTHLY} days..."
    find "${BACKUP_BASE_DIR}/monthly" -name "*.tar.gz" -type f -mtime +${RETENTION_MONTHLY} -delete
    find "${BACKUP_BASE_DIR}/monthly" -name "*.sha256" -type f -mtime +${RETENTION_MONTHLY} -delete

    # Show remaining backups
    log ""
    log "Remaining backups:"
    log "  Daily: $(find "${BACKUP_BASE_DIR}/daily" -name "*.tar.gz" | wc -l)"
    log "  Weekly: $(find "${BACKUP_BASE_DIR}/weekly" -name "*.tar.gz" | wc -l)"
    log "  Monthly: $(find "${BACKUP_BASE_DIR}/monthly" -name "*.tar.gz" | wc -l)"

    success "Cleanup completed"
    log "=========================================="
}

# Display backup statistics
show_stats() {
    log "=========================================="
    log "Backup Statistics"
    log "=========================================="

    for TYPE in daily weekly monthly; do
        BACKUP_DIR="${BACKUP_BASE_DIR}/${TYPE}"
        if [ -d "$BACKUP_DIR" ]; then
            COUNT=$(find "$BACKUP_DIR" -name "*.tar.gz" | wc -l)
            SIZE=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1)
            LATEST=$(find "$BACKUP_DIR" -name "*.tar.gz" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2- | xargs basename 2>/dev/null || echo "None")

            log "${TYPE^} backups:"
            log "  Count: $COUNT"
            log "  Total size: $SIZE"
            log "  Latest: $LATEST"
        fi
    done

    log "=========================================="
}

# =============================================================================
# Main
# =============================================================================

case "${BACKUP_TYPE}" in
    daily|weekly|monthly)
        create_backup
        ;;
    cleanup)
        cleanup_old_backups
        ;;
    stats)
        show_stats
        ;;
    *)
        echo "Usage: $0 [daily|weekly|monthly|cleanup|stats]"
        exit 1
        ;;
esac

exit 0
